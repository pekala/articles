<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/noindex/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/discovering-patterns-with-react-hooks">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/discovering-patterns-with-react-hooks"><div><img src="https://images.ponyfoo.com/uploads/paul-stollery-561842-unsplash-f8b33736db264b85b429d4099b13d121.jpg" alt="Discovering patterns with React hooks"></div></a>

<h1>Discovering patterns with React hooks</h1>

<p><kbd>react</kbd> <kbd>patterns</kbd></p>

<blockquote><p>Exploring a pattern useful for building top-level, centralised functionalities in React apps.</p>
</blockquote>

<div><p>One of the things I enjoy the most about coding is discovering patterns. Being aware and mindful of the patterns emerging in your codebase can make it easier to keep that codebase consistent, readable and easy to navigate. Most patterns will remain unspoken, and some, that prove notably elegant, are named and promoted as best practices. Others might even be candidates for a basis of a new abstraction, although I recommend restraint as it&#x2019;s worth remembering that <a href="https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions" target="_blank" rel="noopener noreferrer">abstractions are expensive</a>.</p></div>

<blockquote></blockquote>

<div><blockquote> <p>If you&#x2019;re not familiar with the topic or React hooks, there is plenty of <a href="https://medium.com/@dan_abramov/making-sense-of-react-hooks-fdbde8803889" target="_blank" rel="noopener noreferrer">introductory</a> as well as <a href="https://www.robinwieruch.de/react-hooks" target="_blank" rel="noopener noreferrer">in-depth materials</a> out there. I can also shamelessly recommend <a href="https://www.youtube.com/watch?v=Vizk0clZHeI" target="_blank" rel="noopener noreferrer">my talk on hooks</a> from a recent React Copenhagen meetup. What follows assume at least some understanding of what hooks are and how to use them.</p> </blockquote></div>

<div><h2 id="pattern-extinction-level-event">Pattern extinction level event</h2> <p>Discovering new patterns is relatively rare when working with established technologies, but every now and then a new idea comes up that stirs things up within some ecosystem. Enter React hooks. Hooks enable a drastically different way to build stateful components in React, which means that they also invalidate <sup><a id="footnote-1" href="#footnote-1-marker" class="md-footnote-ref">1</a></sup> a lot of the established patterns. However, being an exceptionally well thought-through and composition-friendly abstraction, hooks enabled new, elegant patterns to emerge.</p> <p>Over the last few months, I&#x2019;ve been building apps with hooks and I&#x2019;ve been having a lot of fun discovering these patterns. I&#x2019;d like to share one, that I&#x2019;ve grown especially fond of. For the lack of a better name, and for sole the purpose of this blog post, let&#x2019;s call it the Choco&#x1F36B; pattern (from Context, HOok, COmponent). The pattern comes useful when you need a UI widget which is top-level, centralised and unique across the application and needs to expose some functionality to the rest of the components in the app. It might sound vague at the moment, so let&#x2019;s try to go through solving a concrete problem where I noticed the Choco pattern manifest itself.</p> <h2 id="exhibit-a-feature-toggles">Exhibit A: Feature toggles</h2> <p>Let&#x2019;s try to build a simple feature toggle functionality for a React app. There should be UI where the user can toggle features on and off and we want to expose these settings to any component interested. We can identify parts we will need:</p> <ol> <li>a context provider exposing the feature toggles anywhere in the component tree,</li> <li>a component rendering the UI for toggling features,</li> <li>a place to store the feature toggle state and the associated logic.</li> </ol> <p>Our first attempt could look like this:</p> <iframe allow="geolocation; microphone; camera; midi; vr; encrypted-media" src="https://glitch.com/embed/#!/embed/hooks-feature-toggles?path=script.jsx&amp;previewSize=0" alt="hooks-feature-toggles on Glitch" height="417px" width="100%"> </iframe> <p>This code is fairly simple and works so we could stop here. However, there is a big opportunity for refactoring, by moving all the code related to the &#x201C;feature toggle concern&#x201D; to a separate module, instead of mixing it with the rest of our app. Let&#x2019;s do just that.</p> <iframe allow="geolocation; microphone; camera; midi; vr; encrypted-media" src="https://glitch.com/embed/#!/embed/hooks-feature-toggles-2?path=feature-toggle.jsx&amp;previewSize=0" alt="hooks-feature-toggles-2 on Glitch" width="100%" height="431px"> </iframe> <p>The biggest change here is extracting the state and its related logic into a custom hook. We can now clearly see the Choco pattern here, with the Context, HOok, and COmponent exported from the new module.</p> <p>I made a choice here to keep the <code class="md-code md-code-inline">initialFeatures</code> dictionary with the application code instead of moving it to the newly created module. One could argue either way, but by keeping that dictionary out of the feature toggle module and dependency-injecting it, we make that module completely generic and a candidate for possible extraction into a library.</p> <p>Again, we could easily end the refactoring here. In fact, that&#x2019;s the level of decoupling I&#x2019;d recommend for in this scenario (more on that later). We can, however, take it one step further and introduce an abstraction to hide some of the implementation details and reduce the API surface of the module. Here is one way to do this:</p> <iframe allow="geolocation; microphone; camera; midi; vr; encrypted-media" src="https://glitch.com/embed/#!/embed/hooks-feature-toggles-3?path=feature-toggle.jsx&amp;previewSize=0" alt="hooks-feature-toggles-3 on Glitch" width="100%" height="431px"> </iframe> <p>The biggest difference to notice is that the fact we&#x2019;re using the native React context is now an implementation detail, not exposed to the rest of the app. By adding our own abstraction on top of it we also gained a more fine-grain control over what properties of the context are exposed. In this case, we could expose only the feature toggle dictionary, while keeping the function to toggle them private.</p> <p>Another thing to notice is that by wrapping the context provider in a component, we had an opportunity to render the <code class="md-code md-code-inline">FeatureToggler</code> in that component and take that responsibility away from the module&#x2019;s consumer. This might be a viable option if we decide to e.g. render the toggler in a portal to make it overlay the page after the user presses some specific key combination. However, in this example I chose not to - this way is much more flexible as the consumer can choose where and how to render the toggler.</p> <p>What&#x2019;s interesting is that we kept the same type of exports from the feature toggle module (Context, HOok, and COmponent), but they are consumed in a different way. The hook is now taking care of exposing the features to the components. The context (or more precisely the wrapped context provider) now also encapsulates the state and related logic.</p> <p>Did we improve this code in comparison to the previous iteration? I think the answer depends on how we plan to use it. If we decided to extract the feature toggle module into a small library, then that last version of the code is most likely a better choice. It would be easier to document and use the API with a smaller exposed surface. Hiding the implementation details might also enable adding more functionality later on, without introducing breaking changes.</p> <p>However, if we keep it as a module within the codebase the abstraction creates an unnecessary indirection that the next developer would need to unpack to understand. We created a black box that would need to be explored as opposed to the previous version, which while verbose, used the core React APIs most likely already familiar. Since we don&#x2019;t extract and version the module, breaking changes are not a big deal as we could quickly make necessary adjustments in the places where the module is consumed.</p> <h2 id="exhibit-b-toast-notifications">Exhibit B: Toast notifications</h2> <p>It wouldn&#x2019;t be much of a pattern if it didn&#x2019;t repeat. To see how it manifests again and again in this kind of problems, let&#x2019;s look at one more example. We are going to build a simplified toast notification system. We want to be able to ask for a notification anywhere in our component tree and then show it in a global bar. Again, let&#x2019;s identify what pieces we are going to need:</p> <ol> <li>a context provider exposing a function that can be used to ask for a toast,</li> <li>a component rendering the toast bar,</li> <li>a place to store the notifications state and related logic</li> </ol> <p>We already know what to expect so let&#x2019;s skip the first draft and go directly to the version with a separate module:</p> <iframe allow="geolocation; microphone; camera; midi; vr; encrypted-media" src="https://glitch.com/embed/#!/embed/hooks-toasts?path=feature-toggle.jsx&amp;previewSize=0" alt="hooks-toasts on Glitch" width="100%" height="431px"> </iframe> <p>It&#x2019;s our Choco pattern on full display! And as in the previous example, we can refactor this to make the API cleaner and more controlled. It could look like this:</p> <iframe allow="geolocation; microphone; camera; midi; vr; encrypted-media" src="https://glitch.com/embed/#!/embed/hooks-toasts-2?path=toasts.jsx&amp;previewSize=0" alt="hooks-toasts-2 on Glitch" width="100%" height="431px"> </iframe> <p>As in the feature toggle example, I chose to only expose some part of the context value to the component tree through the custom hook. In this case, the array of toasts remains private, while the functions to add and remove toasts are exposed.</p> <h2 id="exhibit-c-user-guide">Exhibit C: User guide</h2> <p>To cement the pattern further, let&#x2019;s look at one last example. We will build user guide functionality. We want to add a help button in some places in our app, which when clicked, opens a user guide widget that explains the part of the interface in question. You know the drill by now, let&#x2019;s see what we&#x2019;re going to need:</p> <ol> <li>a context provider exposing the help icon button component</li> <li>a component rendering the user guide UI</li> <li>a place to store state (i.e. which piece of the interface the user asked for) and related logic</li> </ol> <p>Our first iteration could look like this:</p> <iframe allow="geolocation; microphone; camera; midi; vr; encrypted-media" src="https://glitch.com/embed/#!/embed/hooks-user-guide?path=user-guide.jsx&amp;previewSize=0" alt="hooks-user-guide on Glitch" width="100%" height="431px"> </iframe> <p>Hopefully, the structure is intuitive and familiar by now. The only significant difference is the type of functionality exposed to the other components. In the case of the guide, we choose to expose a component, while in the previous examples it was a method or state data. Anything goes!</p> <p>Following the previously established procedure, the refactored version of the same code could look like this:</p> <iframe allow="geolocation; microphone; camera; midi; vr; encrypted-media" src="https://glitch.com/embed/#!/embed/hooks-user-guide-2?path=user-guide.jsx&amp;previewSize=0" alt="hooks-user-guide-2 on Glitch" width="100%" height="431px"> </iframe> <h2 id="spot-the-pattern">Spot the pattern</h2> <p>Of course, I slightly cheated with the way I presented the refactoring evolution here. I already knew the pattern and made the examples follow it from the very beginning. In fact, when I first got to implement these features using hooks, I didn&#x2019;t immediately see the Choco pattern and my initial implementation attempts were chaotic and inconsistent. But with time, I started to see the same code paths and elements showing up repeatedly and I was able to streamline and clean up my implementations.</p> <p>Discovering and embracing patterns can be a powerful technique that can make penetrating and understanding a codebase easier. I&#x2019;m always on a lookout for concerns and features that share similar requirements and characteristics and try to implement them in a consistent way, without introducing abstractions prematurely.</p> <p>I&#x2019;m really eager to find out what other concerns are candidates for using this pattern and what other patterns using hooks will surface. Let me know what you think!</p> <div class="md-footnotes"> <div id="footnote-1-marker" class="md-footnote"><a href="#footnote-1" class="md-footnote-anchor">1</a><div><p>Of course, hooks being backward-compatible, you can still use old patterns in React if you stick to the class component API.</p> </div></div> </div></div>
